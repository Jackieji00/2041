			   __________________

			    LAB 02 QUESTIONS
			   __________________


- Name: Jackie Ji
- NetID: ji000011

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete the
lab.


PROBLEM 1: last_elem recursive function
=======================================

(A)
~~~

  Start the OCaml REPL in the `lab02-code' directory and load the
  `rec_funcs.ml' source file with a `#use' directive as shown.

  ,----
  | > ocaml
  | 	OCaml version 4.06.0
  | 
  | # #use "rec_funcs.ml";;
  | val last_elem : 'a list -> 'a = <fun>
  | val elems_outside : int -> int -> 'a list -> 'a list = <fun>
  | #
  `----

  The first function loaded from the source file is called `last_elem'.

  Describe in words the type of `last_elem' :
  - What kind of argument does it take?
  - What type does it return?
  - What does the 'a notation mean?

It takes a list and returns an any type. 'a mean an any type variable


(B)
~~~

  Call `last_elem' on several input lists in the REPL and show the
  return values.
  - Make sure to call the function on an empty list and report what
    happens.
  - Make sure to use several different types of lists (int list, string
    list) and a few different lengths.

  Paste your REPL transcript below AND describe in a line or two what
  the function does.
# last_elem []
  ;;
Exception: Failure "No last element in an empty list".
# last_elem ["a";"B";"c"]
  ;;
- : string = "c"
# last_elem [1;2;3;4]
  ;;
- : int = 4

It takes an list as input and output the last element.If it is empty list,
 it will raise an exception

(C)
~~~

  Examine the definition of `last_elem' in `rec_funcs.ml'. Study how it
  operates carefully to gain insight on recursive functions.

  Add comments in your own words that describe line-by-line how the
  function operates. Paste your commented version of the code below.

let rec last_elem list =                      (*a recursive function*)
  if list = [] then                           (*if it is empty list*)
    raise (Failure "No last element in an empty list") (* raise an exception*)
  else                                        (*if it is not empty list*)
    let elem = List.hd list in                (*set first one in list as variable elem *)
    let rest = List.tl list in                (*set the rest part of list as variable rest*)
    if rest = [] then                         (*if it is the last one*)
      elem                                    (*return elem*)
    else                                      (*if it is not the last one*)
      last_elem rest                          (*recursive the rest *)
;;

PROBLEM 2: elems_outside with recursive helper function
=======================================================

(A)
~~~

  The other function loaded by `rec_funcs.ml' is called `elems_outside'.
  As before, describe it's type.
  - How many parameters does it take and what type are they?
  - What type does it return?

It takes 3 parameters, int, int, and 'a list, and return 'a list. 

(B)
~~~

  In the REPL, call `elems_outside' on several lengths and types of
  lists. Show the results generated by these calls by pasting your REPL
  session below. Describe what the function appears to be doing.
   
   # elems_outside 3 5 [0; 1; 2; 3; 4; 5; 6; 7];;
   - : int list = [0; 1; 2; 6; 7]
   # elems_outside 1 5 [0; 1; 2; 3; 4; 5; 6; 7];;
   - : int list = [0; 6; 7]
   # elems_outside 2 4 [0; 1; 2; 3; 4; 5; 6; 7];;
   - : int list = [0; 1; 5; 6; 7]
   # elems_outside 2 4 [];;
   - : 'a list = []
this functions takes two int and a list, get rid of the numbers between these two number
and return the rest in the list. 

(C)
~~~

  Examine the definition of `elems_outside' in `rec_funcs.ml'. Study how
  it operates carefully to gain insight on recursive functions.

  Add comments in your own words that describe line-by-line how the
  function operates. Paste your commented version of the code below.

let elems_outside start stop list =           (*set a function name it elems_outside*)
  let rec helper pos lst =                    (*set a recursive fucntion as helper*)
    if lst=[] then                            (*if the input list is empty*)
      []                                      (*return an empty list *)
    else if start<=pos && pos<=stop then      (*if postion are smaller than start and stop*)
      helper (pos+1) (List.tl lst)            (*keep recursive next*)
    else                                      (*if it not*)
      let elem = List.hd lst in               (*set first one in list as variable elem *)
      let rest = List.tl lst in               (*set the rest part of list as variable rest*)
      let result =  helper (pos+1) rest in    (*set result as next recursive next*)
      elem :: result                          (*attach elem with result*)
  in                                          (*in*)
  helper 0 list                               (*call helper func with inputs 0 and list*)
;;

Problem 3
=========

(A)
~~~

  Examine the two functions provided in `sorting.ml': `sorted_insert'
  and `sort'. Describe the parameter and return types for both
  functions. Based on the comments and source code, determine their
  purpose.

sorted_insert takes an any type and a list as input , and returns a list.
it insert a variable into a sorted list in sorted order.
sort takes a list and return a list; it sort a list by using sorted_insert. 

(B)
~~~

  The code provided for this problem is an adaptation of code from the
  Ocaml System Manual Section 1.2 which is here
  [http://caml.inria.fr/pub/docs/manual-ocaml/coreexamples.html#sec9]

  The original version looks like this:
  ,----
  | let rec sort lst =
  |   match lst with
  |     [] -> []
  |   | head :: tail -> insert head (sort tail)
  | and insert elt lst =
  |   match lst with
  |     [] -> [elt]
  |   | head :: tail -> if elt <= head then elt :: lst else head :: insert elt tail
  | ;;
  `----

  The version in `sorting.ml' has been re-written so that it is somewhat
  more verbose but potentially easier for a novice to understand.
  - Ordering of the functions is reversed so that insertion is defined
    prior to sorting
  - Two separate "let" bindings are used rather than a joint "let/and"
    binding
  - Pattern matching via "match" is replaced with "if/else" statements
  - Destructure binding is replaced with explicit calls to List.hd and
    List.tl

  All of the above concepts will eventually be covered and it does not
  hurt one to look ahead a bit.

  COMPARE the code in `sorting.ml' to the original OSM version above.
  Make some observations about how the syntax associated with the
  "match" statement must work.

all the match -with follows following patters.
match lst with 
[]->[] means if lst ==[] then [];
| this means else if
in general match-with is like something switch in java.   
